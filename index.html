<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ZenScore | Fluid Sheet Music Reader</title>
    
    <!-- Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <!-- Initialize PDF Worker -->
    <script>
        if (window.pdfjsLib) {
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }
    </script>

    <style>
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            overflow: hidden;
            touch-action: none; 
            margin: 0;
            padding: 0;
            background-color: #f0f2f5; /* Default bg */
        }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }

        /* Animations */
        @keyframes fadeInScale { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        @keyframes slideUpFade { from { opacity: 0; transform: translateY(40px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes slideDownFade { from { opacity: 0; transform: translateY(-40px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes pageTurnRight { from { transform: translateX(40px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes pageTurnLeft { from { transform: translateX(-40px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

        .anim-enter { animation-duration: 0.5s; animation-timing-function: cubic-bezier(0.22, 1, 0.36, 1); animation-fill-mode: both; }
        .anim-fade-scale { animation-name: fadeInScale; }
        .anim-slide-up { animation-name: slideUpFade; }
        .anim-slide-down { animation-name: slideDownFade; }
        .anim-page-next { animation: pageTurnRight 0.3s cubic-bezier(0.22, 1, 0.36, 1); }
        .anim-page-prev { animation: pageTurnLeft 0.3s cubic-bezier(0.22, 1, 0.36, 1); }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        // --- DATABASE LAYER (IndexedDB) ---
        const DB_NAME = 'ZenScoreDB';
        const DB_VERSION = 1;

        const initDB = () => {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('metadata')) db.createObjectStore('metadata', { keyPath: 'id' });
                    if (!db.objectStoreNames.contains('files')) db.createObjectStore('files', { keyPath: 'id' });
                };
                request.onsuccess = (e) => resolve(e.target.result);
                request.onerror = (e) => reject(e.target.error);
            });
        };

        const dbOp = async (storeName, mode, callback) => {
            const db = await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(storeName, mode);
                const store = tx.objectStore(storeName);
                const req = callback(store);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        };

        const saveToDB = async (docMeta, fileBlob) => {
            await dbOp('files', 'readwrite', store => store.put({ id: docMeta.id, file: fileBlob }));
            await dbOp('metadata', 'readwrite', store => store.put(docMeta));
        };

        const loadLibrary = async () => { return await dbOp('metadata', 'readonly', store => store.getAll()); };
        const loadFile = async (id) => { const result = await dbOp('files', 'readonly', store => store.get(id)); return result ? result.file : null; };
        const updateStrokesInDB = async (id, strokes) => {
            const db = await initDB();
            const tx = db.transaction('metadata', 'readwrite');
            const store = tx.objectStore('metadata');
            const req = store.get(id);
            req.onsuccess = () => {
                const data = req.result;
                if (data) { data.strokes = strokes; data.date = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}); store.put(data); }
            };
        };
        const deleteFromDB = async (id) => { await dbOp('files', 'readwrite', store => store.delete(id)); await dbOp('metadata', 'readwrite', store => store.delete(id)); };

        // --- Constants ---
        const COLORS = ['#1e1e1e', '#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ffffff'];
        const STROKE_SIZES = [2, 4, 6, 8, 12, 20];

        const TRANSITIONS = {
            spring: "transition-all duration-500 ease-[cubic-bezier(0.22,1,0.36,1)]",
            slide: "transition-transform duration-500 ease-[cubic-bezier(0.22,1,0.36,1)]",
            fade: "transition-opacity duration-300 ease-in-out"
        };

        // --- Helpers ---
        const getCoordinates = (event, canvasRef) => {
            if (!canvasRef.current) return { x: 0, y: 0 };
            const canvas = canvasRef.current;
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            if (event.changedTouches && event.changedTouches.length > 0) {
                clientX = event.changedTouches[0].clientX;
                clientY = event.changedTouches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }
            return {
                x: (clientX - rect.left) * (canvas.width / rect.width),
                y: (clientY - rect.top) * (canvas.height / rect.height)
            };
        };

        // --- Components ---
        const Icon = ({ name, size = 24, className = "", ...props }) => {
            const iconKey = name.charAt(0).toLowerCase() + name.slice(1);
            const iconDef = window.lucide?.icons?.[name] || window.lucide?.icons?.[iconKey];
            if (!iconDef) return null;
            return (
                <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>
                    {iconDef.map((child, index) => { const Tag = child[0]; return <Tag key={index} {...child[1]} />; })}
                </svg>
            );
        };

        const IconButton = ({ icon, active, onClick, title, disabled, className = "", badge = null, darkMode }) => (
            <button onClick={onClick} title={title} disabled={disabled} className={`p-3 rounded-[16px] ${TRANSITIONS.spring} flex items-center justify-center relative group active:scale-95 hover:scale-105 ${disabled ? 'opacity-30 cursor-not-allowed' : ''} ${active ? 'bg-blue-600 text-white shadow-lg scale-105 ring-1 ring-black/5' : !disabled && (darkMode ? 'hover:bg-white/10 text-zinc-200' : 'hover:bg-white/50 text-[#4a5b6c] hover:shadow-sm')} ${className}`}>
                <Icon name={icon} size={20} />
                {badge && <span className="absolute top-2 right-2 w-2 h-2 bg-[#e17055] rounded-full border border-white dark:border-black"></span>}
                {!disabled && <span className={`absolute -top-10 left-1/2 -translate-x-1/2 ${darkMode ? 'bg-white text-black' : 'bg-white/90 text-[#4a5b6c]'} backdrop-blur border border-white/50 text-[10px] px-3 py-1 rounded-full opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none whitespace-nowrap z-50 font-medium tracking-wide shadow-sm`}>{title}</span>}
            </button>
        );

        const ColorDot = ({ color, active, onClick, darkMode }) => (
            <button onClick={() => onClick(color)} className={`w-9 h-9 rounded-full border-[3px] ${TRANSITIONS.spring} active:scale-95 shadow-sm ${active ? 'scale-110 border-blue-500 shadow-md ring-2 ring-blue-500/20' : `border-transparent hover:scale-105 ring-1 ${darkMode ? 'ring-white/20' : 'ring-black/5 hover:ring-black/10'}`}`} style={{ backgroundColor: color }} />
        );

        const PageThumbnail = ({ pdfDoc, pageNum, isActive, onClick, darkMode }) => {
            const canvasRef = useRef(null);
            const [loaded, setLoaded] = useState(false);
            useEffect(() => {
                if (!pdfDoc) return;
                let isCancelled = false;
                const renderThumb = async () => {
                    try {
                        const page = await pdfDoc.getPage(pageNum);
                        if (isCancelled) return;
                        const viewport = page.getViewport({ scale: 0.3 }); 
                        const canvas = canvasRef.current;
                        if (!canvas) return;
                        canvas.width = viewport.width;
                        canvas.height = viewport.height;
                        const ctx = canvas.getContext('2d');
                        await page.render({ canvasContext: ctx, viewport }).promise;
                        if (!isCancelled) setLoaded(true);
                    } catch (e) {}
                };
                renderThumb();
                return () => { isCancelled = true; };
            }, [pdfDoc, pageNum]);

            return (
                <div onClick={onClick} className={`relative group cursor-pointer flex flex-col items-center ${TRANSITIONS.spring} ${isActive ? 'scale-105' : 'hover:scale-105 opacity-80 hover:opacity-100'} active:scale-100`}>
                    <div className={`relative rounded-[24px] overflow-hidden shadow-lg ${darkMode ? 'bg-zinc-800' : 'bg-white'} ${TRANSITIONS.spring} ${isActive ? 'ring-[3px] ring-[#9fb3a8] shadow-xl' : `ring-1 ${darkMode ? 'ring-white/10' : 'ring-white/80'}`}`}>
                        <canvas ref={canvasRef} className={`w-full h-auto block transition-opacity duration-500 ${loaded ? 'opacity-100' : 'opacity-0'}`} />
                        {!loaded && <div className={`absolute inset-0 animate-pulse ${darkMode ? 'bg-zinc-800' : 'bg-gray-50'}`} />}
                    </div>
                    <div className="absolute -bottom-3 -right-3 z-10"><div className={`flex items-center justify-center w-8 h-8 rounded-full ${darkMode ? 'bg-zinc-800 border-zinc-700 text-zinc-400' : 'bg-white border-white/80 text-[#4a5b6c]'} shadow-md font-sans text-sm ${TRANSITIONS.spring} ${isActive ? 'font-bold' : 'opacity-60'}`}>{pageNum}</div></div>
                </div>
            );
        };

        const LibraryCard = ({ doc, onClick, onDelete, darkMode }) => (
            <div onClick={doc.type === 'loading' ? null : onClick} className={`group relative flex flex-col gap-3 cursor-pointer anim-enter anim-fade-scale ${doc.type === 'loading' ? 'opacity-70 pointer-events-none' : ''}`}>
                <div className={`relative aspect-[3/4] rounded-[24px] overflow-hidden shadow-lg ring-1 ${darkMode ? 'bg-zinc-900 ring-white/10' : 'bg-[rgba(255,255,255,0.85)] ring-white/90'} backdrop-blur-sm ${TRANSITIONS.spring} group-hover:-translate-y-2 active:-translate-y-1 group-hover:shadow-2xl`}>
                    {doc.type === 'loading' ? (
                        <div className={`w-full h-full flex flex-col items-center justify-center gap-3 ${darkMode ? 'bg-zinc-800/50' : ''}`}>
                            <Icon name="Loader" size={32} className={`animate-spin ${darkMode ? 'text-zinc-500' : 'text-slate-400'}`} />
                            <span className={`text-xs font-medium ${darkMode ? 'text-zinc-500' : 'text-slate-400'}`}>Processing...</span>
                        </div>
                    ) : doc.thumbnail ? (
                        <img src={doc.thumbnail} className="w-full h-full object-cover transition-transform duration-700 group-hover:scale-105 opacity-90 group-hover:opacity-100" alt="Cover" />
                    ) : (
                        <div className={`w-full h-full flex items-center justify-center ${darkMode ? 'bg-zinc-800/50' : ''}`}><Icon name="FileText" size={40} className={darkMode ? 'text-zinc-600' : "text-[#9fb3a8]"} /></div>
                    )}
                    
                    {doc.type !== 'loading' && (
                        <>
                            <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-500" />
                            <div className="absolute bottom-5 left-5 text-white opacity-0 group-hover:opacity-100 transition-all duration-500 translate-y-2 group-hover:translate-y-0"><p className="text-[10px] font-bold uppercase tracking-widest mb-1 text-[#9fb3a8]">Last opened</p><div className="flex items-center gap-1.5"><Icon name="Clock" size={12} /><p className="text-xs opacity-90 font-medium">{doc.date}</p></div></div>
                            <button onClick={(e) => { e.stopPropagation(); onDelete(doc.id); }} className={`absolute top-3 right-3 p-2 rounded-full bg-white/10 hover:bg-red-500/80 text-white backdrop-blur-md opacity-0 group-hover:opacity-100 transition-all hover:scale-110 active:scale-90`} title="Delete Score"><Icon name="Trash2" size={16} /></button>
                        </>
                    )}
                </div>
                <div className="px-2 text-center"><h3 className={`font-semibold truncate text-lg ${darkMode ? 'text-zinc-100' : 'text-[#4a5b6c]'}`}>{doc.name}</h3>
                {doc.type !== 'loading' && <p className={`text-sm font-medium ${darkMode ? 'text-zinc-500' : 'text-[#4a5b6c]/60'}`}>{doc.numPages} Pages</p>}
                </div>
            </div>
        );

        // --- Main Application ---
        function ZenScore() {
            const [viewMode, setViewMode] = useState('library');
            const [library, setLibrary] = useState([]);
            const [activeDoc, setActiveDoc] = useState(null);
            const [file, setFile] = useState(null); // Raw Image for Background
            const [pdfDoc, setPdfDoc] = useState(null);
            const [currentPage, setCurrentPage] = useState(1);
            const [numPages, setNumPages] = useState(0);
            const [mode, setMode] = useState('view');
            const [scale, setScale] = useState(1);
            const [pan, setPan] = useState({ x: 0, y: 0 });
            const [isDrawing, setIsDrawing] = useState(false);
            const [pageStrokes, setPageStrokes] = useState({});
            const [redoStack, setRedoStack] = useState([]);
            const [currentStroke, setCurrentStroke] = useState(null);
            const [color, setColor] = useState('#2d3436');
            const [brushSize, setBrushSize] = useState(4);
            const [showTools, setShowTools] = useState(false);
            const [animClass, setAnimClass] = useState('');
            const [uiVisible, setUiVisible] = useState(true);
            const [touchStart, setTouchStart] = useState(null);
            const [inputMethod, setInputMethod] = useState('finger');
            const [renderScaleFactor, setRenderScaleFactor] = useState(1); // Track PDF render quality

            // DARK MODE STATE
            const [darkMode, setDarkMode] = useState(() => {
                if (typeof window !== 'undefined' && window.matchMedia) return window.matchMedia('(prefers-color-scheme: dark)').matches;
                return false;
            });

            // THREE CANVASES FOR VSYNC PERFORMANCE
            const bgCanvasRef = useRef(null); // Static Image
            const staticInkCanvasRef = useRef(null); // Saved Strokes
            const activeInkCanvasRef = useRef(null); // Current Stroke (Fast)
            const containerRef = useRef(null);
            const fileInputRef = useRef(null);

            useEffect(() => {
                loadLibrary().then(docs => { setLibrary(docs.sort((a,b) => b.id - a.id)); });
            }, []);
            
            const generateThumbnail = async (pdf) => {
                try {
                    const page = await pdf.getPage(1);
                    const viewport = page.getViewport({ scale: 0.3 });
                    const canvas = document.createElement('canvas');
                    canvas.width = viewport.width; canvas.height = viewport.height;
                    const ctx = canvas.getContext('2d');
                    await page.render({ canvasContext: ctx, viewport }).promise;
                    return canvas.toDataURL('image/jpeg', 0.6);
                } catch (e) { return null; }
            };

            const handleFileLoad = (e) => {
                const selectedFile = e.target.files[0];
                if (!selectedFile) return;
                
                const tempId = Date.now();
                const placeholder = { id: tempId, name: selectedFile.name.replace(/\.[^/.]+$/, ""), type: 'loading' };
                setLibrary(prev => [placeholder, ...prev]);

                const processFile = async (fileData, type, numPages = 1, pdf = null) => {
                    let thumb = null;
                    if (type === 'pdf' && pdf) { thumb = await generateThumbnail(pdf); }
                    else if (type === 'image') { thumb = fileData; }

                    const newDoc = {
                        id: tempId,
                        name: selectedFile.name.replace(/\.[^/.]+$/, ""),
                        thumbnail: thumb,
                        numPages: numPages,
                        date: new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}),
                        type: type,
                        strokes: {} 
                    };

                    try {
                        await saveToDB(newDoc, fileData);
                        setLibrary(prev => prev.map(doc => doc.id === tempId ? newDoc : doc));
                        openDocument(newDoc, pdf);
                    } catch (err) {
                        console.error("DB Save Error", err);
                        setLibrary(prev => prev.filter(doc => doc.id !== tempId));
                        alert("Failed to save.");
                    }
                };

                if (selectedFile.type === 'application/pdf') {
                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            if (!window.pdfjsLib) { alert("Loading lib..."); return; }
                            const buffer = event.target.result;
                            const pdfBuffer = buffer.slice(0); 
                            const pdf = await window.pdfjsLib.getDocument(pdfBuffer).promise;
                            await processFile(new Uint8Array(buffer), 'pdf', pdf.numPages, pdf);
                        } catch (err) { 
                            setLibrary(prev => prev.filter(doc => doc.id !== tempId));
                            alert("Error: " + err.message); 
                        }
                    };
                    reader.readAsArrayBuffer(selectedFile);
                } else if (selectedFile.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => { processFile(event.target.result, 'image'); };
                    reader.readAsDataURL(selectedFile);
                }
            };

            const handleDelete = async (id) => { if(confirm("Delete this score?")) { await deleteFromDB(id); setLibrary(prev => prev.filter(doc => doc.id !== id)); } };

            // --- AUTO FIT LOGIC ---
            const fitPageToScreen = (width, height, renderedScale) => {
                 // renderedScale is how much the image is bigger than 'real' dimensions (e.g. 2.0)
                 // But we don't care about 'real' units for fit, we care about pixels.
                 // The image is width x height pixels.
                 const screenWidth = window.innerWidth;
                 const screenHeight = window.innerHeight;
                 
                 // We want the image to fit within screen width mostly
                 // transform scale is applied to the container.
                 // Visual width = width * scale
                 // We want Visual width = screenWidth
                 // scale = screenWidth / width
                 
                 const scaleW = screenWidth / width;
                 const scaleH = screenHeight / height;
                 
                 // Fit width or height, whichever is smaller, to ensure visibility
                 const bestScale = Math.min(scaleW, scaleH) * 0.95; // 95% to leave margin
                 
                 setScale(bestScale);
                 
                 // Center
                 const centeredX = (screenWidth - (width * bestScale)) / 2;
                 setPan({ x: Math.max(0, centeredX), y: 10 });
            };

            const renderPdfPageFromObj = async (page) => {
                const pixelRatio = window.devicePixelRatio || 1;
                // Cap render quality to 2.0 to prevent crashes on huge PDFs
                const rScale = Math.min(pixelRatio * 1.5, 2.0); 
                setRenderScaleFactor(rScale); // Save this so we know later if needed

                const viewport = page.getViewport({ scale: rScale });
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width; canvas.height = viewport.height;
                
                await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
                
                const img = new Image(); 
                img.src = canvas.toDataURL('image/jpeg');
                
                img.onload = () => { 
                    setFile(img); 
                    // ONLY AUTO-FIT if this is the first load of this page context? 
                    // User requested "automatically recognize page size and make full page shows EVERY TIME score is loaded"
                    // We interpret "loaded" as file opening.
                    // If we do it on page turn, it snaps. Let's do it on render.
                    fitPageToScreen(img.width, img.height, rScale);
                };
            };

            const openDocument = async (doc, loadedPdf = null) => {
                if (doc.type === 'loading') return;
                setPageStrokes(doc.strokes || {}); setRedoStack([]); setFile(null); setCurrentPage(1);
                setActiveDoc(doc); setNumPages(doc.numPages);
                setUiVisible(true);

                if (!loadedPdf && doc.type === 'pdf') {
                    const buffer = await loadFile(doc.id);
                    if(!buffer) { alert("File not found."); return; }
                    const pdf = await window.pdfjsLib.getDocument(buffer).promise;
                    setPdfDoc(pdf);
                    const page = await pdf.getPage(1);
                    renderPdfPageFromObj(page);
                    setViewMode('work'); 
                } else if (doc.type === 'image') {
                    const dataUrl = await loadFile(doc.id);
                    if(!dataUrl) { alert("File not found."); return; }
                    const img = new Image(); img.src = dataUrl; 
                    img.onload = () => { 
                        setFile(img); 
                        fitPageToScreen(img.width, img.height, 1);
                        setViewMode('work'); 
                    };
                } else if (loadedPdf) {
                    setPdfDoc(loadedPdf);
                    const page = await loadedPdf.getPage(1);
                    renderPdfPageFromObj(page);
                    setViewMode('work');
                }
            };

            const renderPdfPage = async (pdf, pageNum) => {
                try {
                    const page = await pdf.getPage(pageNum);
                    renderPdfPageFromObj(page);
                } catch (err) { console.error(err); }
            };

            const changePage = (offset) => {
                const next = currentPage + offset;
                if (next >= 1 && next <= numPages && pdfDoc) {
                    setAnimClass(offset > 0 ? 'anim-page-next' : 'anim-page-prev');
                    setTimeout(() => setAnimClass(''), 400);
                    setCurrentPage(next);
                    renderPdfPage(pdfDoc, next);
                }
            };

            const jumpToPage = (n) => { 
                setCurrentPage(n); 
                pdfDoc.getPage(n).then(page => {
                    renderPdfPageFromObj(page);
                });
                setViewMode('work'); 
            };
            
            const getCurrentStrokes = () => pageStrokes[currentPage] || [];
            
            // --- TRIPLE-LAYER RENDERING ---
            
            // 1. Background Image
            const drawBackground = () => {
                const canvas = bgCanvasRef.current;
                if (!canvas || !file) return;
                // Sync sizes
                if (canvas.width !== file.width || canvas.height !== file.height) {
                    canvas.width = file.width; canvas.height = file.height;
                    if (staticInkCanvasRef.current) { staticInkCanvasRef.current.width = file.width; staticInkCanvasRef.current.height = file.height; }
                    if (activeInkCanvasRef.current) { activeInkCanvasRef.current.width = file.width; activeInkCanvasRef.current.height = file.height; }
                }
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(file, 0, 0);
            };

            // 2. Static Ink (Saved Strokes)
            const drawStaticInk = () => {
                const canvas = staticInkCanvasRef.current;
                if (!canvas || !file) return;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                
                getCurrentStrokes().forEach(s => { 
                    ctx.beginPath(); ctx.strokeStyle = s.color; ctx.lineWidth = s.size; 
                    ctx.globalCompositeOperation = s.tool === 'erase' ? 'destination-out' : 'source-over'; 
                    if(s.points.length){ ctx.moveTo(s.points[0].x,s.points[0].y); s.points.forEach(p=>ctx.lineTo(p.x,p.y)); } 
                    ctx.stroke(); 
                });
            };

            // 3. Active Ink (Current Stroke)
            const drawActiveInk = () => {
                const canvas = activeInkCanvasRef.current;
                if (!canvas || !file) return;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Fast clear
                
                if (currentStroke) { 
                    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                    ctx.beginPath(); 
                    ctx.strokeStyle = currentStroke.color; 
                    ctx.lineWidth = currentStroke.size; 
                    ctx.globalCompositeOperation = currentStroke.tool === 'erase' ? 'destination-out' : 'source-over'; 
                    if(currentStroke.points.length){
                        ctx.moveTo(currentStroke.points[0].x,currentStroke.points[0].y); 
                        currentStroke.points.forEach(p=>ctx.lineTo(p.x,p.y));
                    } 
                    ctx.stroke(); 
                }
            };

            useEffect(() => { if(window.pdfjsLib) window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js'; }, []);
            
            // React to changes
            useEffect(() => { if (viewMode === 'work' && file) drawBackground(); }, [file, viewMode]); 
            useEffect(() => { if (viewMode === 'work' && file) drawStaticInk(); }, [pageStrokes, viewMode, file]); 
            useEffect(() => { if (viewMode === 'work' && file) drawActiveInk(); }, [currentStroke, viewMode, file]);
            
            // Force redraw on resize to keep sync
            useEffect(() => { 
                const r = () => { if(viewMode === 'work' && file) { drawBackground(); drawStaticInk(); drawActiveInk(); }}; 
                window.addEventListener('resize', r); return () => window.removeEventListener('resize', r); 
            }, [file, viewMode]);
            
            useEffect(() => { const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)'); const handleChange = (e) => setDarkMode(e.matches); mediaQuery.addEventListener('change', handleChange); return () => mediaQuery.removeEventListener('change', handleChange); }, []);

            // --- Object Erase Logic ---
            const hitTestStroke = (x, y, strokes) => {
                const threshold = 10 / scale;
                for (let i = strokes.length - 1; i >= 0; i--) {
                    const s = strokes[i];
                    if (s.points.length < 2) continue;
                    for (let j = 0; j < s.points.length - 1; j++) {
                        const p1 = s.points[j];
                        const p2 = s.points[j+1];
                        const A = x - p1.x; const B = y - p1.y; const C = p2.x - p1.x; const D = p2.y - p1.y;
                        const dot = A * C + B * D;
                        const len_sq = C * C + D * D;
                        let param = -1;
                        if (len_sq !== 0) param = dot / len_sq;
                        let xx, yy;
                        if (param < 0) { xx = p1.x; yy = p1.y; }
                        else if (param > 1) { xx = p2.x; yy = p2.y; }
                        else { xx = p1.x + param * C; yy = p1.y + param * D; }
                        const dx = x - xx; const dy = y - yy;
                        if ((dx * dx + dy * dy) < (threshold * threshold)) return i; 
                    }
                }
                return -1;
            };

            // --- Input Handlers ---
            const handleTouchStart = (e) => {
                const touches = e.touches;
                if (touches.length === 2) {
                    if(isDrawing) { setIsDrawing(false); setCurrentStroke(null); } 
                    const dist = Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
                    setTouchStart({ x: (touches[0].clientX + touches[1].clientX) / 2, y: (touches[0].clientY + touches[1].clientY) / 2, dist: dist, initialScale: scale, initialPan: { ...pan }, count: 2 });
                } else if (touches.length === 1) {
                    if (mode === 'view') {
                        setTouchStart({ x: touches[0].clientX, y: touches[0].clientY, count: 1 });
                    } else {
                        if (inputMethod === 'stylus') {
                            // Check if touches[0] is stylus. If not, it's a PAN gesture.
                            // Note: touchType support varies. Fallback logic handled in pointer events.
                            // If user touches with finger in stylus mode, we start a PAN.
                            const isStylus = touches[0].touchType === 'stylus';
                            if (!isStylus) {
                                setTouchStart({ x: touches[0].clientX, y: touches[0].clientY, count: 1 });
                            }
                        } else {
                            // Finger Mode -> Let PointerDown handle drawing
                        }
                    }
                }
            };

            const handleTouchMove = (e) => {
                e.preventDefault(); 
                const touches = e.touches;
                if (touches.length === 2 && touchStart && touchStart.count === 2) {
                    const dist = Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
                    const centerX = (touches[0].clientX + touches[1].clientX) / 2;
                    const centerY = (touches[0].clientY + touches[1].clientY) / 2;
                    const scaleFactor = dist / touchStart.dist;
                    const newScale = Math.min(Math.max(0.5, touchStart.initialScale * scaleFactor), 5);
                    const deltaX = centerX - touchStart.x;
                    const deltaY = centerY - touchStart.y;
                    setScale(newScale);
                    setPan({ x: touchStart.initialPan.x + deltaX, y: touchStart.initialPan.y + deltaY });
                } else if (touches.length === 1) {
                    if (mode === 'view' || (mode !== 'view' && inputMethod === 'stylus')) {
                         if(touchStart && touchStart.count === 1) {
                            const deltaX = touches[0].clientX - touchStart.x;
                            const deltaY = touches[0].clientY - touchStart.y;
                            setPan(p => ({ x: p.x + deltaX, y: p.y + deltaY }));
                            setTouchStart({ x: touches[0].clientX, y: touches[0].clientY, count: 1 });
                        }
                    }
                }
            };

            const handleTouchEnd = (e) => {
                if (!touchStart) return;
                if ((mode === 'view' || inputMethod === 'stylus') && touchStart.count === 1 && e.changedTouches.length === 1) {
                    const touch = e.changedTouches[0];
                    const distMoved = Math.hypot(touch.clientX - touchStart.x, touch.clientY - touchStart.y);
                    if (distMoved < 10) { setUiVisible(!uiVisible); }
                }
                setTouchStart(null);
            };

            const handlePointerDown = (e) => { 
                if(mode==='view') return; 
                // STYLUS MODE: Only accept pen input
                if (inputMethod === 'stylus' && e.pointerType !== 'pen') return; 

                e.currentTarget.setPointerCapture(e.pointerId); 
                const {x,y} = getCoordinates(e, activeInkCanvasRef);
                
                if (mode === 'object-eraser') {
                    const hitIndex = hitTestStroke(x, y, getCurrentStrokes());
                    if (hitIndex !== -1) {
                        const newStrokes = [...getCurrentStrokes()];
                        newStrokes.splice(hitIndex, 1);
                        const finalStrokes = {...pageStrokes, [currentPage]: newStrokes};
                        setPageStrokes(finalStrokes);
                        if(activeDoc) updateStrokesInDB(activeDoc.id, finalStrokes);
                    }
                    return;
                }
                
                setIsDrawing(true); 
                setCurrentStroke({tool:mode, color:mode==='erase'?'#000000':color, size:brushSize, points:[{x,y}]}); 
            };
            
            const handlePointerMove = (e) => { 
                const {x,y}=getCoordinates(e, activeInkCanvasRef); 
                
                if (mode === 'object-eraser' && (e.buttons === 1 || e.pressure > 0)) {
                    const hitIndex = hitTestStroke(x, y, getCurrentStrokes());
                    if (hitIndex !== -1) {
                        const newStrokes = [...getCurrentStrokes()];
                        newStrokes.splice(hitIndex, 1);
                        const finalStrokes = {...pageStrokes, [currentPage]: newStrokes};
                        setPageStrokes(finalStrokes);
                        if(activeDoc) updateStrokesInDB(activeDoc.id, finalStrokes);
                    }
                    return;
                }

                if(!isDrawing||!currentStroke) return; 
                setCurrentStroke(prev=>({...prev, points:[...prev.points,{x,y}]})); 
            };
            
            const handlePointerUp = (e) => { 
                if(!isDrawing||!currentStroke) return; 
                setIsDrawing(false); 
                const newStrokes = {...pageStrokes, [currentPage]:[...(pageStrokes[currentPage]||[]), currentStroke]}; 
                setPageStrokes(newStrokes); 
                setCurrentStroke(null); 
                if(activeDoc) updateStrokesInDB(activeDoc.id, newStrokes); 
            };
            
            const undo = () => { const s = getCurrentStrokes(); if(s.length) { const newStrokes = {...pageStrokes, [currentPage]: s.slice(0,-1)}; setPageStrokes(newStrokes); if(activeDoc) updateStrokesInDB(activeDoc.id, newStrokes); } };
            const redo = () => {}; 
            const handleWheel = (e) => { if(e.ctrlKey) { e.preventDefault(); setScale(s => Math.min(Math.max(0.5, s + (e.deltaY * -0.01)), 4)); } };

            const appStyle = { background: darkMode ? 'linear-gradient(135deg, #18181b 0%, #09090b 100%)' : 'linear-gradient(135deg, #f0f2f5 0%, #eef2f3 100%)', color: darkMode ? '#e4e4e7' : '#4a5b6c' };

            return (
                <div className={`h-screen w-full overflow-hidden relative select-none ${TRANSITIONS.fade} flex flex-col`} style={appStyle}>
                    {viewMode === 'library' && (
                        <div className="absolute inset-0 z-50 flex flex-col anim-enter anim-fade-scale">
                            <div className="h-24 px-8 flex items-center justify-between">
                                <h1 className="text-lg font-normal tracking-[0.15em] uppercase opacity-70 flex items-center gap-3"><span className="w-2 h-8 bg-[#9fb3a8] rounded-full"></span> ZenFlow</h1>
                                <div className="flex gap-4 items-center">
                                    <button onClick={() => setDarkMode(!darkMode)} className={`p-3 rounded-full ${TRANSITIONS.spring} ${darkMode ? 'hover:bg-white/10 text-zinc-300' : 'hover:bg-black/5 text-slate-600'}`}>
                                        <Icon name={darkMode ? "Sun" : "Moon"} size={20} />
                                    </button>
                                    <button onClick={() => fileInputRef.current?.click()} className={`px-8 py-3 rounded-[16px] font-semibold shadow-lg flex items-center gap-3 ${darkMode ? 'bg-zinc-800 text-zinc-100 hover:bg-zinc-700' : 'bg-white text-[#4a5b6c] hover:shadow-xl'} active:scale-95 ${TRANSITIONS.spring}`}><Icon name="Plus" size={18} /> Import Score</button>
                                    <input type="file" ref={fileInputRef} onChange={handleFileLoad} accept="image/*,application/pdf" className="hidden" />
                                </div>
                            </div>
                            <div className="flex-1 overflow-y-auto p-8 scrollbar-hide">
                                {library.length === 0 ? (
                                    <div className="h-full flex flex-col items-center justify-center pb-32 anim-enter anim-slide-up">
                                        <div className={`w-32 h-32 rounded-[24px] mb-8 flex items-center justify-center ${darkMode ? 'bg-zinc-900 border-zinc-800' : 'bg-[rgba(255,255,255,0.85)] border-white/90'} border shadow-sm`}><Icon name="ImageIcon" size={48} className={darkMode ? "text-zinc-700" : "text-[#9fb3a8]"} /></div>
                                        <h2 className="text-xl font-normal mb-2 opacity-80">Your library is empty</h2>
                                        <p className="text-sm opacity-60 max-w-sm text-center">Import a PDF or image to get started.</p>
                                    </div>
                                ) : (
                                    <div className={`grid gap-8 pb-20 grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5`}>
                                        {library.map(doc => (
                                            <LibraryCard key={doc.id} doc={doc} onClick={() => openDocument(doc)} onDelete={handleDelete} darkMode={darkMode} />
                                        ))}
                                    </div>
                                )}
                            </div>
                        </div>
                    )}
                    {viewMode === 'overview' && (
                        <div className={`absolute inset-0 z-40 flex flex-col backdrop-blur-md anim-enter anim-slide-up ${darkMode ? 'bg-zinc-950/90' : 'bg-[#f0f2f5]/90'}`}>
                            <div className={`h-24 flex items-center justify-between px-8 shrink-0 ${darkMode ? 'border-zinc-800' : 'border-slate-200'} border-b`}>
                                <div className="w-1/3"><button onClick={() => setViewMode('library')} className={`flex items-center gap-2 font-semibold px-5 py-2 rounded-[16px] ${TRANSITIONS.spring} ${darkMode ? 'bg-zinc-800/50 text-zinc-300 hover:bg-zinc-800' : 'bg-white/50 text-[#4a5b6c] hover:bg-white'} shadow-sm`}><Icon name="ChevronLeft" size={18} /> Library</button></div>
                                <div className="w-1/3 flex flex-col items-center"><span className={`font-normal text-lg tracking-wide ${darkMode ? 'text-zinc-100' : 'text-[#4a5b6c]'}`}>{activeDoc?.name}</span><span className="text-[10px] font-bold opacity-40 uppercase tracking-[0.2em] mt-1">{activeDoc?.numPages} Pages</span></div>
                                <div className="w-1/3 flex justify-end gap-3"><button onClick={() => setDarkMode(!darkMode)} className={`p-3 rounded-full ${TRANSITIONS.spring} ${darkMode ? 'hover:bg-white/10 text-zinc-300' : 'hover:bg-black/5 text-slate-600'}`}><Icon name={darkMode ? "Sun" : "Moon"} size={20} /></button></div>
                            </div>
                            <div className="flex-1 overflow-y-auto p-10 scrollbar-hide">
                                {pdfDoc && <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-10 pb-20">{Array.from({ length: numPages }, (_, i) => i + 1).map((pageNum) => <PageThumbnail key={pageNum} pdfDoc={pdfDoc} pageNum={pageNum} isActive={currentPage === pageNum} onClick={() => jumpToPage(pageNum)} darkMode={darkMode} />)}</div>}
                            </div>
                        </div>
                    )}
                    {viewMode === 'work' && (
                        <>
                            <div className={`absolute top-0 left-0 right-0 h-24 pointer-events-none z-20 flex items-center justify-between px-8 ${TRANSITIONS.spring} ${uiVisible ? 'translate-y-0 opacity-100' : '-translate-y-full opacity-0'}`}>
                                <div className="pointer-events-auto flex items-center gap-4">
                                    <IconButton icon="LayoutGrid" onClick={() => setViewMode('overview')} title="Overview" className={`${darkMode ? 'bg-zinc-900/80 border-zinc-700 text-zinc-100' : 'bg-[rgba(255,255,255,0.65)] border-white/80'} border backdrop-blur-md shadow-sm fixed top-6 left-6`} darkMode={darkMode} />
                                    <div className={`flex items-center gap-2 ${darkMode ? 'bg-zinc-900/80 border-zinc-700 text-zinc-100' : 'bg-[rgba(255,255,255,0.65)] border-white/80 text-[#4a5b6c]'} backdrop-blur-md px-5 py-2 rounded-[16px] text-sm font-semibold shadow-sm border fixed top-6 left-24 ${TRANSITIONS.spring}`}><span className="opacity-40 mr-1">PG</span><span className="text-lg">{currentPage}</span><span className="opacity-40">/ {numPages}</span></div>
                                </div>
                                <div className="pointer-events-auto flex gap-2"><IconButton icon={darkMode ? "Sun" : "Moon"} onClick={() => setDarkMode(!darkMode)} title="Theme" className={`${darkMode ? 'bg-zinc-900/80 border-zinc-700 text-zinc-300' : 'bg-[rgba(255,255,255,0.65)] border-white/80 text-[#4a5b6c]'} border backdrop-blur-md shadow-sm fixed top-6 right-6`} darkMode={darkMode} /></div>
                            </div>

                            <div 
                                ref={containerRef} 
                                className={`flex-1 h-full overflow-hidden flex items-center justify-center cursor-${mode === 'view' ? 'grab' : 'crosshair'} anim-enter anim-fade-scale`}
                                onWheel={handleWheel} 
                                onTouchStart={handleTouchStart} 
                                onTouchMove={handleTouchMove} 
                                onTouchEnd={handleTouchEnd}
                            >
                                <div className={`relative shadow-[0_20px_50px_rgba(0,0,0,0.1)] origin-center ${animClass}`} style={{ transform: `scale(${scale}) translate(${pan.x}px, ${pan.y}px)` }}>
                                    {/* Layer 1: Background Image */}
                                    <canvas ref={bgCanvasRef} className="absolute inset-0 pointer-events-none" />
                                    {/* Layer 2: Static Ink (Saved) */}
                                    <canvas ref={staticInkCanvasRef} className="absolute inset-0 pointer-events-none" />
                                    {/* Layer 3: Active Ink (Drawing) - Receives Events */}
                                    <canvas ref={activeInkCanvasRef} className="absolute inset-0 z-10" onPointerDown={handlePointerDown} onPointerMove={handlePointerMove} onPointerUp={handlePointerUp} onPointerLeave={handlePointerUp} />
                                </div>
                            </div>

                            <div className={`fixed bottom-8 left-1/2 -translate-x-1/2 z-30 flex flex-col items-center gap-6 ${TRANSITIONS.spring} ${uiVisible ? 'translate-y-0 opacity-100' : 'translate-y-20 opacity-0 pointer-events-none'}`}>
                                <div className={`overflow-hidden rounded-[40px] ${darkMode ? 'bg-zinc-900/90 border-zinc-700' : 'bg-[rgba(255,255,255,0.85)] border-white/90'} backdrop-blur-md border shadow-lg ${TRANSITIONS.spring} origin-bottom ${showTools && mode !== 'view' ? 'max-h-96 opacity-100 scale-100 mb-0' : 'max-h-0 opacity-0 scale-90 mb-[-20px] pointer-events-none'}`}>
                                    <div className="p-6 flex flex-col gap-5 min-w-[300px]">
                                        <div className="flex gap-3 justify-center">{COLORS.map(c => <ColorDot key={c} color={c} active={color === c && mode !== 'erase' && mode !== 'object-eraser'} onClick={(c) => { setColor(c); setMode('draw'); }} darkMode={darkMode} />)}</div>
                                        <div className={`flex items-center gap-3 pt-4 border-t ${darkMode ? 'border-zinc-700' : 'border-[#4a5b6c]/10'} justify-center`}>
                                            {STROKE_SIZES.map(s => <button key={s} onClick={() => setBrushSize(s)} className={`relative flex items-center justify-center w-10 h-10 rounded-full ${TRANSITIONS.spring} active:scale-95 ${brushSize === s ? 'scale-100 opacity-100' : 'scale-75 opacity-40 hover:opacity-100'}`}><div className={`absolute inset-0 rounded-full border-2 ${TRANSITIONS.spring} ${brushSize === s ? 'border-[#74b9ff]' : 'border-transparent'}`} /><div className={`rounded-full ${TRANSITIONS.spring} ${brushSize === s ? 'bg-[#74b9ff]' : (darkMode ? 'bg-zinc-600' : 'bg-[#4a5b6c]')}`} style={{ width: `${Math.max(s, 4)}px`, height: `${Math.max(s, 4)}px` }} /></button>)}
                                        </div>
                                        <div className={`pt-4 border-t ${darkMode ? 'border-zinc-700' : 'border-[#4a5b6c]/10'} flex justify-between items-center`}>
                                            <span className={`text-xs font-bold uppercase tracking-widest ${darkMode ? 'text-zinc-500' : 'text-[#4a5b6c]/60'}`}>Input Mode</span>
                                            <button onClick={() => setInputMethod(m => m === 'finger' ? 'stylus' : 'finger')} className={`px-4 py-2 rounded-xl text-xs font-bold uppercase tracking-wider transition-all ${inputMethod === 'stylus' ? 'bg-[#74b9ff] text-white shadow-md' : (darkMode ? 'bg-zinc-800 text-zinc-400' : 'bg-white/50 text-[#4a5b6c]')}`}>{inputMethod === 'stylus' ? 'Stylus Only' : 'Finger Draw'}</button>
                                        </div>
                                    </div>
                                </div>
                                <div className={`flex items-center gap-1 p-1.5 px-2 rounded-[50px] backdrop-blur-md ${darkMode ? 'bg-zinc-900/80 border-zinc-700 shadow-black/50' : 'bg-[rgba(255,255,255,0.65)] border-white/80 shadow-sm'} border ${TRANSITIONS.spring}`}>
                                    <div className={`flex items-center gap-1 ml-1 pr-2 border-r ${darkMode ? 'border-zinc-700' : 'border-[#4a5b6c]/10'}`}>
                                        <IconButton icon="ArrowLeft" onClick={undo} title="Undo" disabled={getCurrentStrokes().length === 0} darkMode={darkMode} />
                                        <IconButton icon="ArrowRight" onClick={redo} title="Redo" disabled={redoStack.length === 0} darkMode={darkMode} />
                                    </div>
                                    <div className={`flex items-center overflow-hidden ${TRANSITIONS.spring} ${numPages > 1 ? 'max-w-[120px] opacity-100 mr-2' : 'max-w-0 opacity-0 mr-0'}`}>
                                        <div className="flex items-center gap-1 w-full justify-center"><IconButton icon="ChevronLeft" onClick={() => { if(currentPage > 1) changePage(-1); }} disabled={currentPage <= 1} title="Prev" darkMode={darkMode} /><IconButton icon="ChevronRight" onClick={() => { if(currentPage < numPages) changePage(1); }} disabled={currentPage >= numPages} title="Next" darkMode={darkMode} /></div>
                                    </div>
                                    {numPages > 1 && <div className={`w-px h-6 ${darkMode ? 'bg-zinc-700' : 'bg-[#4a5b6c]/10'} mx-1`}></div>}
                                    <div className={`flex items-center gap-1 ${darkMode ? 'bg-zinc-800/50' : 'bg-white/50'} rounded-[40px] p-1 shadow-inner`}>
                                        <IconButton icon="Move" active={mode === 'view'} onClick={() => { setMode('view'); setShowTools(false); }} title="Pan" darkMode={darkMode} />
                                        <IconButton icon="PenTool" active={mode === 'draw'} onClick={() => { setMode('draw'); setShowTools(true); }} title="Pen" darkMode={darkMode} />
                                        <IconButton icon="Eraser" active={mode === 'erase'} onClick={() => { setMode('erase'); setShowTools(true); }} title="Eraser" darkMode={darkMode} />
                                        <IconButton icon="Trash" active={mode === 'object-eraser'} onClick={() => { setMode('object-eraser'); setShowTools(false); }} title="Object Eraser" className="text-red-500 hover:bg-red-100" darkMode={darkMode} />
                                    </div>
                                    <div className={`flex items-center overflow-hidden ${TRANSITIONS.spring} ${mode !== 'view' && mode !== 'object-eraser' ? 'max-w-[60px] opacity-100 ml-2' : 'max-w-0 opacity-0 ml-0'}`}><div className={`w-px h-6 ${darkMode ? 'bg-zinc-700' : 'bg-[#4a5b6c]/10'} mx-1 shrink-0`}></div><IconButton icon={showTools ? "ChevronUp" : "Settings2"} className={`transition-transform duration-300 ${showTools ? `rotate-180 ${darkMode ? 'bg-zinc-700' : 'bg-white'} shadow-sm` : ''}`} onClick={() => setShowTools(!showTools)} title="Tools" darkMode={darkMode} /></div>
                                </div>
                            </div>
                        </>
                    )}
                </div>
            );
        }
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ZenScore />);
    </script>
</body>
</html>
